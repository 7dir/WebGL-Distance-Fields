// Distance map contour texturing by Stefan Gustavson, 2011.
// A reimplementation of Greens method, with a 16-bit distance map and explicit bilinear interpolation.
// This code is in the public domain.

varying vec2 vUv;

uniform sampler2D tDiffuse;
uniform float texw;
uniform float texh;

// Replacement for RSLs 'filterstep()', with fwidth() done right.
// threshold is constant, value is smoothly varying
float aastep (float threshold , float value)
{
	float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));
	
	// GLSLs fwidth(value) is abs(dFdx(value)) + abs(dFdy(value))
	return smoothstep(threshold - afwidth, threshold + afwidth, value);
}

void main()
{
	// Scale texcoords to range ([0, texw], [0, texh])
	vec2 uv = vUv * vec2(texw, texh);

	// Compute texel-local (u,v) coordinates for the four closest texels
	vec2 uv00 = floor(uv - vec2(0.5)); // Lower left corner of lower left texel
	vec2 uvlerp = uv - uv00 - vec2(0.5); // Texel-local lerp blends [0,1]

	// Center st00 on lower left texel and rescale to [0,1] for texture lookup
	vec2 st00 = (uv00 + vec2(0.5)) * vec2(1.0 / texw, 1.0 / texh);

	// Compute distance value from four closest 8-bit RGBA texels
	vec4 D00 = texture2D(tDiffuse, st00);
	vec4 D10 = texture2D(tDiffuse, st00 + vec2(1.0 / texw, 0.0));
	vec4 D01 = texture2D(tDiffuse, st00 + vec2(0.0, 1.0 / texh));
	vec4 D11 = texture2D(tDiffuse, st00 + vec2(1.0 / texw, 1.0 / texh));

	// Restore the values for D from their 8.8 fixed point encoding
	vec2 D00_10 = vec2(D00.r, D10.r) * 255.0 - 128.0 + vec2(D00.g, D10.g) * (255.0 / 256.0);
	vec2 D01_11 = vec2(D01.r, D11.r) * 255.0 - 128.0 + vec2(D01.g, D11.g) * (255.0 / 256.0);

	// Interpolate along v
	vec2 D0_1 = mix(D00_10, D01_11, uvlerp.y);
	
	// Interpolate along u
	float D = mix(D0_1.x, D0_1.y, uvlerp.x);

	float g = aastep(0.0, D);
	
	// Final fragment color
	gl_FragColor = vec4(vec3(g), 1.0);
}