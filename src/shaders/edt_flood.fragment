// Jump flooding algorithm for Euclidean distance transform, according to Danielsson (1980) and Guodong Rong (2007).
// Implementation by Stefan Gustavson 2010. This code is in the public domain.
// This code represents one iteration of the flood filling.
// You need to run it multiple times with different step lengths to perform a full distance transformation.

varying vec2 vUv;
varying float stepu;
varying float stepv;

uniform sampler2D tDiffuse;
uniform float texw;
uniform float texh;
uniform float texLevels;

// Helper function to remap unsigned normalized floats [0.0..1.0]
// coming from a texture stored in integer format internally to a
// signed float vector pointing exactly to a pixel centre in texture
// space. The range of valid vectors is
// [-1.0+0.5/texsize, 1.0-0.5/texsize], with the special value
// -1.0-0.5*texsize (represented as integer 0) meaning
// "distance vector still undetermined".
// The mapping is carefully designed to map both 8 bit and 16
// bit integer texture data to distinct and exact floating point
// texture coordinate offsets and vice versa.
// 8 bit integer textures can be used to transform images up to
// size 128x128 pixels, and 16 bit integer textures can be used to
// transform images up to 32768x32768, i.e. beyond the largest
// texture size available in current implementations of OpenGL.
// Direct use of integers in the shader (by means of texture2DRect
// and GL_RG8I and GL_RG16I texture formats) could be faster, but
// this code is conveniently compatible even with version 1.2 of GLSL
// (i.e. OpenGL 2.1), and the main shader is limited by texture access
// and branching, not ALU capacity, so a few extra multiplications
// for indexing and output storage are not that bad.
vec2 remap(vec2 floatdata)
{
     return floatdata * (texLevels - 1.0) / texLevels * 2.0 - 1.0;
}

vec2 remap_inv(vec2 floatvec)
{
     return (floatvec + 1.0) * 0.5 * texLevels / (texLevels - 1.0);
}

// TODO fix this, its hideous
vec3 sampleTexture(sampler2D texture, vec2 vec)
{
	if(vec.x >= 1.0 || vec.y >= 1.0 || vec.x <= 0.0 || vec.y <= 0.0)
	{
		vec = clamp(vec, 0.0, 1.0);
		return vec3(0.0, 0.0, 0.0);
	}
	
	return texture2D(texture, vec).rgb;
}

void main()
{
	// Search for better distance vectors among 8 candidates
	vec2 stepvec; // Relative offset to candidate being tested
	vec2 newvec; // Absolute position of that candidate
	vec4 newseed; // Closest point from that candidate (.xy),
				 // its AA distance (.z) and its grayscale value (.w)
	vec4 bestseed; // Closest seed so far
	vec3 texel;
	texel = sampleTexture(tDiffuse, vUv).rgb;
	bestseed.xy = remap(texel.rg);
	
	// TODO: This AA assumes texw=texh. It does not allow for non-square textures.
	bestseed.z = length(bestseed.xy) + (texel.b - 0.5) / texw; // Add AA edge offset
	bestseed.w = texel.b; // Save AA edge offset

	// This code depends on the texture having a CLAMP_TO_BORDER attribute and a border color with R = 0.
	// The commented-out lines handle clamping to the edge explicitly to avoid propagating incorrect vectors when looking outside of [0,1] in u and/or v.
	// These explicit conditionals cause a slowdown of about 25%. Sometimes a periodic transform with edge repeats might be what you want. In that case, the texture wrap mode can be set to GL_REPEAT, and the shader code can be left unchanged.
	stepvec = vec2(-stepu, -stepv);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
	  // If the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	stepvec = vec2(-stepu, 0.0);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
	  // if the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	stepvec = vec2(-stepu, stepv);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
	  // if the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	stepvec = vec2(0.0, -stepv);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
      // if the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	stepvec = vec2(0.0, stepv);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
	  // if the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	stepvec = vec2(stepu, -stepv);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
	  // if the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	stepvec = vec2(stepu, 0.0);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
	  // if the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	stepvec = vec2(stepu, stepv);
	newvec = vUv + stepvec;
	texel = sampleTexture(tDiffuse, newvec).rgb;
	newseed.xy = remap(texel.rg);
	if(newseed.x > -0.99999)
	{
	  // if the new seed is not "indeterminate distance"
	  newseed.xy = newseed.xy + stepvec;
	  newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
	  newseed.w = texel.b;
	  if(newseed.z < bestseed.z)
	  {
		bestseed = newseed;
	  }
	}

	gl_FragColor = vec4(remap_inv(bestseed.xy), bestseed.w, 1.0);
}